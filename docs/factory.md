# Фабрика

**Фабричный метод** - порождающий шаблон проектирования, предоставляющий подклассам интерфейс для создания экземпляров некоторого класса.

В данном пакете, **фабрика** - это коллекция `callback` объектов, которые облегчают создание других объектов.

## Создание

Для создания фабрики, достаточно вызвать соответствующий конструктор:

```php
use jugger\di\Factory;

$factory = new Factory();
```

Для удобства работы с фабрикой существует глобальный класс `Di` доступный в любой части приложения.
Поэтому лучше, создавать фабрику таким образом:

```php
Di::$f = new Factory();
```

## Работа с фабрикой

Класс `Factory` реализует интерфейс `ArrayAccess`, поэтому работать с фабрикой можно также, как и с массивом:

```php
Di::$f['a'] = 123;
Di::$f['b'] = function() {
    return mt_rand();
};

$a = Di::$f['a']; // 123
$b = Di::$f['b']; // rand number
$c = Di::$f['b']; // rand number
$c == $b; // false
```

Обратитие внимание, фабрика возвращает не сам `Closure`, а именно его значение.
Также обратите внимание, что фабрика не кеширует значения.

## Жизненный пример

Рассмотрим ситуацию когда используются классы из других пакетов `jugger`.
Допустим у нас есть приложение с разными базами, для разных целей: чтение и запись.
Без использования фабрики, создание соответствующих объектов, будет выглядеть так:

```php
use jugger\db\Query;
use jugger\db\Command;
use jugger\db\ConnectionPool;

$pool = new ConnectionPool([
    'write' => [
        'class' => 'jugger\db\driver\PdoConnection',
        'dsn' => 'sqlite:write.db',
    ],
    'read' => [
        'class' => 'jugger\db\driver\PdoConnection',
        'dsn' => 'sqlite:read.db',
    ],
]);

$command = new Command($pool['write']);
$query = new Query($pool['read']);
```

С использованием фабрики, создания команды и запроса, можно реализовать так:

```php
Di::$f['cmd'] = function() use($pool) {
    return new Command($pool['write']);
};
Di::$f['query'] = function() use($pool) {
    return new Query($pool['write']);
};

$command = Di::$f['cmd'];
$query = Di::$f['query'];
```

## Не совсем паттерн

По факту, класс `Factory` - это просто набор глобальных переменных и функций, которые можно динамически добавлять, изменять и удалять.
Поэтому назвать полноценной реализацией паттерна, данный класс не назвать.
